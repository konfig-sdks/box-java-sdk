/*
 * Box Platform API
 * [Box Platform](https://box.dev) provides functionality to provide access to content stored within [Box](https://box.com). It provides endpoints for basic manipulation of files and folders, management of users within an enterprise, as well as more complex topics such as legal holds and retention policies.
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: devrel@box.com
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.api;

import com.konfigthis.client.ApiCallback;
import com.konfigthis.client.ApiClient;
import com.konfigthis.client.ApiException;
import com.konfigthis.client.ApiResponse;
import com.konfigthis.client.Configuration;
import com.konfigthis.client.Pair;
import com.konfigthis.client.ProgressRequestBody;
import com.konfigthis.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.konfigthis.client.model.ClientError;
import com.konfigthis.client.model.Events;
import java.time.OffsetDateTime;
import com.konfigthis.client.model.RealtimeServers;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class EventsApiGenerated {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public EventsApiGenerated() throws IllegalArgumentException {
        this(Configuration.getDefaultApiClient());
    }

    public EventsApiGenerated(ApiClient apiClient) throws IllegalArgumentException {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call eventsCall(String streamType, String streamPosition, Long limit, List<String> eventType, OffsetDateTime createdAfter, OffsetDateTime createdBefore, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/events";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (streamType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("stream_type", streamType));
        }

        if (streamPosition != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("stream_position", streamPosition));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (eventType != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("csv", "event_type", eventType));
        }

        if (createdAfter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("created_after", createdAfter));
        }

        if (createdBefore != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("created_before", createdBefore));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2Security" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call eventsValidateBeforeCall(String streamType, String streamPosition, Long limit, List<String> eventType, OffsetDateTime createdAfter, OffsetDateTime createdBefore, final ApiCallback _callback) throws ApiException {
        return eventsCall(streamType, streamPosition, limit, eventType, createdAfter, createdBefore, _callback);

    }


    private ApiResponse<Events> eventsWithHttpInfo(String streamType, String streamPosition, Long limit, List<String> eventType, OffsetDateTime createdAfter, OffsetDateTime createdBefore) throws ApiException {
        okhttp3.Call localVarCall = eventsValidateBeforeCall(streamType, streamPosition, limit, eventType, createdAfter, createdBefore, null);
        Type localVarReturnType = new TypeToken<Events>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call eventsAsync(String streamType, String streamPosition, Long limit, List<String> eventType, OffsetDateTime createdAfter, OffsetDateTime createdBefore, final ApiCallback<Events> _callback) throws ApiException {

        okhttp3.Call localVarCall = eventsValidateBeforeCall(streamType, streamPosition, limit, eventType, createdAfter, createdBefore, _callback);
        Type localVarReturnType = new TypeToken<Events>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class EventsRequestBuilder {
        private String streamType;
        private String streamPosition;
        private Long limit;
        private List<String> eventType;
        private OffsetDateTime createdAfter;
        private OffsetDateTime createdBefore;

        private EventsRequestBuilder() {
        }

        /**
         * Set streamType
         * @param streamType Defines the type of events that are returned  * &#x60;all&#x60; returns everything for a user and is the default * &#x60;changes&#x60; returns events that may cause file tree changes   such as file updates or collaborations. * &#x60;sync&#x60; is similar to &#x60;changes&#x60; but only applies to synced folders * &#x60;admin_logs&#x60; returns all events for an entire enterprise and   requires the user making the API call to have admin permissions. This   stream type is for programmatically pulling from a 1 year history of   events across all users within the enterprise and within a   &#x60;created_after&#x60; and &#x60;created_before&#x60; time frame. The complete history   of events will be returned in chronological order based on the event   time, but latency will be much higher than &#x60;admin_logs_streaming&#x60;. * &#x60;admin_logs_streaming&#x60; returns all events for an entire enterprise and   requires the user making the API call to have admin permissions. This   stream type is for polling for recent events across all users within   the enterprise. Latency will be much lower than &#x60;admin_logs&#x60;, but   events will not be returned in chronological order and may   contain duplicates. (optional, default to all)
         * @return EventsRequestBuilder
         */
        public EventsRequestBuilder streamType(String streamType) {
            this.streamType = streamType;
            return this;
        }
        
        /**
         * Set streamPosition
         * @param streamPosition The location in the event stream to start receiving events from.  * &#x60;now&#x60; will return an empty list events and the latest stream position for initialization. * &#x60;0&#x60; or &#x60;null&#x60; will return all events. (optional)
         * @return EventsRequestBuilder
         */
        public EventsRequestBuilder streamPosition(String streamPosition) {
            this.streamPosition = streamPosition;
            return this;
        }
        
        /**
         * Set limit
         * @param limit Limits the number of events returned  Note: Sometimes, the events less than the limit requested can be returned even when there may be more events remaining. This is primarily done in the case where a number of events have already been retrieved and these retrieved events are returned rather than delaying for an unknown amount of time to see if there are any more results. (optional, default to 100)
         * @return EventsRequestBuilder
         */
        public EventsRequestBuilder limit(Long limit) {
            this.limit = limit;
            return this;
        }
        
        /**
         * Set eventType
         * @param eventType A comma-separated list of events to filter by. This can only be used when requesting the events with a &#x60;stream_type&#x60; of &#x60;admin_logs&#x60; or &#x60;adming_logs_streaming&#x60;. For any other &#x60;stream_type&#x60; this value will be ignored. (optional)
         * @return EventsRequestBuilder
         */
        public EventsRequestBuilder eventType(List<String> eventType) {
            this.eventType = eventType;
            return this;
        }
        
        /**
         * Set createdAfter
         * @param createdAfter The lower bound date and time to return events for. This can only be used when requesting the events with a &#x60;stream_type&#x60; of &#x60;admin_logs&#x60;. For any other &#x60;stream_type&#x60; this value will be ignored. (optional)
         * @return EventsRequestBuilder
         */
        public EventsRequestBuilder createdAfter(OffsetDateTime createdAfter) {
            this.createdAfter = createdAfter;
            return this;
        }
        
        /**
         * Set createdBefore
         * @param createdBefore The upper bound date and time to return events for. This can only be used when requesting the events with a &#x60;stream_type&#x60; of &#x60;admin_logs&#x60;. For any other &#x60;stream_type&#x60; this value will be ignored. (optional)
         * @return EventsRequestBuilder
         */
        public EventsRequestBuilder createdBefore(OffsetDateTime createdBefore) {
            this.createdBefore = createdBefore;
            return this;
        }
        
        /**
         * Build call for events
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returns a list of event objects.  Events objects are returned in pages, with each page (chunk) including a list of event objects. The response includes a &#x60;chunk_size&#x60; parameter indicating how many events were returned in this chunk, as well as the next &#x60;stream_position&#x60; that can be queried. </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> An unexpected client error. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return eventsCall(streamType, streamPosition, limit, eventType, createdAfter, createdBefore, _callback);
        }


        /**
         * Execute events request
         * @return Events
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returns a list of event objects.  Events objects are returned in pages, with each page (chunk) including a list of event objects. The response includes a &#x60;chunk_size&#x60; parameter indicating how many events were returned in this chunk, as well as the next &#x60;stream_position&#x60; that can be queried. </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> An unexpected client error. </td><td>  -  </td></tr>
         </table>
         */
        public Events execute() throws ApiException {
            ApiResponse<Events> localVarResp = eventsWithHttpInfo(streamType, streamPosition, limit, eventType, createdAfter, createdBefore);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute events request with HTTP info returned
         * @return ApiResponse&lt;Events&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returns a list of event objects.  Events objects are returned in pages, with each page (chunk) including a list of event objects. The response includes a &#x60;chunk_size&#x60; parameter indicating how many events were returned in this chunk, as well as the next &#x60;stream_position&#x60; that can be queried. </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> An unexpected client error. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Events> executeWithHttpInfo() throws ApiException {
            return eventsWithHttpInfo(streamType, streamPosition, limit, eventType, createdAfter, createdBefore);
        }

        /**
         * Execute events request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returns a list of event objects.  Events objects are returned in pages, with each page (chunk) including a list of event objects. The response includes a &#x60;chunk_size&#x60; parameter indicating how many events were returned in this chunk, as well as the next &#x60;stream_position&#x60; that can be queried. </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> An unexpected client error. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Events> _callback) throws ApiException {
            return eventsAsync(streamType, streamPosition, limit, eventType, createdAfter, createdBefore, _callback);
        }
    }

    /**
     * List user and enterprise events
     * Returns up to a year of past events for a given user or for the entire enterprise.  By default this returns events for the authenticated user. To retrieve events for the entire enterprise, set the &#x60;stream_type&#x60; to &#x60;admin_logs_streaming&#x60; for live monitoring of new events, or &#x60;admin_logs&#x60; for querying across historical events. The user making the API call will need to have admin privileges, and the application will need to have the scope &#x60;manage enterprise properties&#x60; checked.
     * @return EventsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a list of event objects.  Events objects are returned in pages, with each page (chunk) including a list of event objects. The response includes a &#x60;chunk_size&#x60; parameter indicating how many events were returned in this chunk, as well as the next &#x60;stream_position&#x60; that can be queried. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected client error. </td><td>  -  </td></tr>
     </table>
     */
    public EventsRequestBuilder events() throws IllegalArgumentException {
        return new EventsRequestBuilder();
    }
    private okhttp3.Call events_0Call(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/events";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2Security" };
        return localVarApiClient.buildCall(basePath, localVarPath, "OPTIONS", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call events_0ValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return events_0Call(_callback);

    }


    private ApiResponse<RealtimeServers> events_0WithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = events_0ValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<RealtimeServers>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call events_0Async(final ApiCallback<RealtimeServers> _callback) throws ApiException {

        okhttp3.Call localVarCall = events_0ValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<RealtimeServers>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class Events0RequestBuilder {

        private Events0RequestBuilder() {
        }

        /**
         * Build call for events_0
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returns a paginated array of servers that can be used instead of the regular endpoints for long-polling events. </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> An unexpected client error. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return events_0Call(_callback);
        }


        /**
         * Execute events_0 request
         * @return RealtimeServers
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returns a paginated array of servers that can be used instead of the regular endpoints for long-polling events. </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> An unexpected client error. </td><td>  -  </td></tr>
         </table>
         */
        public RealtimeServers execute() throws ApiException {
            ApiResponse<RealtimeServers> localVarResp = events_0WithHttpInfo();
            return localVarResp.getResponseBody();
        }

        /**
         * Execute events_0 request with HTTP info returned
         * @return ApiResponse&lt;RealtimeServers&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returns a paginated array of servers that can be used instead of the regular endpoints for long-polling events. </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> An unexpected client error. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<RealtimeServers> executeWithHttpInfo() throws ApiException {
            return events_0WithHttpInfo();
        }

        /**
         * Execute events_0 request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returns a paginated array of servers that can be used instead of the regular endpoints for long-polling events. </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> An unexpected client error. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<RealtimeServers> _callback) throws ApiException {
            return events_0Async(_callback);
        }
    }

    /**
     * Get events long poll endpoint
     * Returns a list of real-time servers that can be used for long-polling updates to the [event stream](https://raw.githubusercontent.com).  Long polling is the concept where a HTTP request is kept open until the server sends a response, then repeating the process over and over to receive updated responses.  Long polling the event stream can only be used for user events, not for enterprise events.  To use long polling, first use this endpoint to retrieve a list of long poll URLs. Next, make a long poll request to any of the provided URLs.  When an event occurs in monitored account a response with the value &#x60;new_change&#x60; will be sent. The response contains no other details as it only serves as a prompt to take further action such as sending a request to the [events endpoint](https://raw.githubusercontent.com) with the last known &#x60;stream_position&#x60;.  After the server sends this response it closes the connection. You must now repeat the long poll process to begin listening for events again.  If no events occur for a while and the connection times out you will receive a response with the value &#x60;reconnect&#x60;. When you receive this response you’ll make another call to this endpoint to restart the process.  If you receive no events in &#x60;retry_timeout&#x60; seconds then you will need to make another request to the real-time server (one of the URLs in the response for this endpoint). This might be necessary due to network errors.  Finally, if you receive a &#x60;max_retries&#x60; error when making a request to the real-time server, you should start over by making a call to this endpoint first.
     * @return Events0RequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a paginated array of servers that can be used instead of the regular endpoints for long-polling events. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected client error. </td><td>  -  </td></tr>
     </table>
     */
    public Events0RequestBuilder events_0() throws IllegalArgumentException {
        return new Events0RequestBuilder();
    }
}

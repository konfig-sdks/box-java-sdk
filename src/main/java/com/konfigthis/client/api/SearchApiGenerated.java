/*
 * Box Platform API
 * [Box Platform](https://box.dev) provides functionality to provide access to content stored within [Box](https://box.com). It provides endpoints for basic manipulation of files and folders, management of users within an enterprise, as well as more complex topics such as legal holds and retention policies.
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: devrel@box.com
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.api;

import com.konfigthis.client.ApiCallback;
import com.konfigthis.client.ApiClient;
import com.konfigthis.client.ApiException;
import com.konfigthis.client.ApiResponse;
import com.konfigthis.client.Configuration;
import com.konfigthis.client.Pair;
import com.konfigthis.client.ProgressRequestBody;
import com.konfigthis.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.konfigthis.client.model.ClientError;
import com.konfigthis.client.model.MetadataFilter;
import com.konfigthis.client.model.MetadataQuery;
import com.konfigthis.client.model.MetadataQueryOrderByInner;
import com.konfigthis.client.model.MetadataQueryResults;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class SearchApiGenerated {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public SearchApiGenerated() throws IllegalArgumentException {
        this(Configuration.getDefaultApiClient());
    }

    public SearchApiGenerated(ApiClient apiClient) throws IllegalArgumentException {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call itemsByMetadataCall(MetadataQuery metadataQuery, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = metadataQuery;

        // create path and map variables
        String localVarPath = "/metadata_queries/execute_read";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2Security" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call itemsByMetadataValidateBeforeCall(MetadataQuery metadataQuery, final ApiCallback _callback) throws ApiException {
        return itemsByMetadataCall(metadataQuery, _callback);

    }


    private ApiResponse<MetadataQueryResults> itemsByMetadataWithHttpInfo(MetadataQuery metadataQuery) throws ApiException {
        okhttp3.Call localVarCall = itemsByMetadataValidateBeforeCall(metadataQuery, null);
        Type localVarReturnType = new TypeToken<MetadataQueryResults>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call itemsByMetadataAsync(MetadataQuery metadataQuery, final ApiCallback<MetadataQueryResults> _callback) throws ApiException {

        okhttp3.Call localVarCall = itemsByMetadataValidateBeforeCall(metadataQuery, _callback);
        Type localVarReturnType = new TypeToken<MetadataQueryResults>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ItemsByMetadataRequestBuilder {
        private final String from;
        private final String ancestorFolderId;
        private String query;
        private Map<String, String> queryParams;
        private List<MetadataQueryOrderByInner> orderBy;
        private Integer limit;
        private String marker;
        private List<String> fields;

        private ItemsByMetadataRequestBuilder(String from, String ancestorFolderId) {
            this.from = from;
            this.ancestorFolderId = ancestorFolderId;
        }

        /**
         * Set query
         * @param query The query to perform. A query is a logical expression that is very similar to a SQL &#x60;SELECT&#x60; statement. Values in the search query can be turned into parameters specified in the &#x60;query_param&#x60; arguments list to prevent having to manually insert search values into the query string.  For example, a value of &#x60;:amount&#x60; would represent the &#x60;amount&#x60; value in &#x60;query_params&#x60; object. (optional)
         * @return ItemsByMetadataRequestBuilder
         */
        public ItemsByMetadataRequestBuilder query(String query) {
            this.query = query;
            return this;
        }
        
        /**
         * Set queryParams
         * @param queryParams Set of arguments corresponding to the parameters specified in the &#x60;query&#x60;. The type of each parameter used in the &#x60;query_params&#x60; must match the type of the corresponding metadata template field. (optional)
         * @return ItemsByMetadataRequestBuilder
         */
        public ItemsByMetadataRequestBuilder queryParams(Map<String, String> queryParams) {
            this.queryParams = queryParams;
            return this;
        }
        
        /**
         * Set orderBy
         * @param orderBy A list of template fields and directions to sort the metadata query results by.  The ordering &#x60;direction&#x60; must be the same for each item in the array. (optional)
         * @return ItemsByMetadataRequestBuilder
         */
        public ItemsByMetadataRequestBuilder orderBy(List<MetadataQueryOrderByInner> orderBy) {
            this.orderBy = orderBy;
            return this;
        }
        
        /**
         * Set limit
         * @param limit A value between 0 and 100 that indicates the maximum number of results to return for a single request. This only specifies a maximum boundary and will not guarantee the minimum number of results returned. (optional, default to 100)
         * @return ItemsByMetadataRequestBuilder
         */
        public ItemsByMetadataRequestBuilder limit(Integer limit) {
            this.limit = limit;
            return this;
        }
        
        /**
         * Set marker
         * @param marker Marker to use for requesting the next page. (optional)
         * @return ItemsByMetadataRequestBuilder
         */
        public ItemsByMetadataRequestBuilder marker(String marker) {
            this.marker = marker;
            return this;
        }
        
        /**
         * Set fields
         * @param fields By default, this endpoint returns only the most basic info about the items for which the query matches. This attribute can be used to specify a list of additional attributes to return for any item, including its metadata.  This attribute takes a list of item fields, metadata template identifiers, or metadata template field identifiers.  For example:  * &#x60;created_by&#x60; will add the details of the user who created the item to the response. * &#x60;metadata.&lt;scope&gt;.&lt;templateKey&gt;&#x60; will return the mini-representation of the metadata instance identified by the &#x60;scope&#x60; and &#x60;templateKey&#x60;. * &#x60;metadata.&lt;scope&gt;.&lt;templateKey&gt;.&lt;field&gt;&#x60; will return all the mini-representation of the metadata instance identified by the &#x60;scope&#x60; and &#x60;templateKey&#x60; plus the field specified by the &#x60;field&#x60; name. Multiple fields for the same &#x60;scope&#x60; and &#x60;templateKey&#x60; can be defined. (optional)
         * @return ItemsByMetadataRequestBuilder
         */
        public ItemsByMetadataRequestBuilder fields(List<String> fields) {
            this.fields = fields;
            return this;
        }
        
        /**
         * Build call for itemsByMetadata
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returns a list of files and folders that match this metadata query. </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> An unexpected client error. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            MetadataQuery metadataQuery = buildBodyParams();
            return itemsByMetadataCall(metadataQuery, _callback);
        }

        private MetadataQuery buildBodyParams() {
            MetadataQuery metadataQuery = new MetadataQuery();
            metadataQuery.from(this.from);
            metadataQuery.query(this.query);
            metadataQuery.queryParams(this.queryParams);
            metadataQuery.ancestorFolderId(this.ancestorFolderId);
            metadataQuery.orderBy(this.orderBy);
            metadataQuery.limit(this.limit);
            metadataQuery.marker(this.marker);
            metadataQuery.fields(this.fields);
            return metadataQuery;
        }

        /**
         * Execute itemsByMetadata request
         * @return MetadataQueryResults
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returns a list of files and folders that match this metadata query. </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> An unexpected client error. </td><td>  -  </td></tr>
         </table>
         */
        public MetadataQueryResults execute() throws ApiException {
            MetadataQuery metadataQuery = buildBodyParams();
            ApiResponse<MetadataQueryResults> localVarResp = itemsByMetadataWithHttpInfo(metadataQuery);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute itemsByMetadata request with HTTP info returned
         * @return ApiResponse&lt;MetadataQueryResults&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returns a list of files and folders that match this metadata query. </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> An unexpected client error. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<MetadataQueryResults> executeWithHttpInfo() throws ApiException {
            MetadataQuery metadataQuery = buildBodyParams();
            return itemsByMetadataWithHttpInfo(metadataQuery);
        }

        /**
         * Execute itemsByMetadata request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returns a list of files and folders that match this metadata query. </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> An unexpected client error. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<MetadataQueryResults> _callback) throws ApiException {
            MetadataQuery metadataQuery = buildBodyParams();
            return itemsByMetadataAsync(metadataQuery, _callback);
        }
    }

    /**
     * Query files/folders by metadata
     * Create a search using SQL-like syntax to return items that match specific metadata.  By default, this endpoint returns only the most basic info about the items for which the query matches. To get additional fields for each item, including any of the metadata, use the &#x60;fields&#x60; attribute in the query.
     * @return ItemsByMetadataRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a list of files and folders that match this metadata query. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected client error. </td><td>  -  </td></tr>
     </table>
     */
    public ItemsByMetadataRequestBuilder itemsByMetadata(String from, String ancestorFolderId) throws IllegalArgumentException {
        if (from == null) throw new IllegalArgumentException("\"from\" is required but got null");
            

        if (ancestorFolderId == null) throw new IllegalArgumentException("\"ancestorFolderId\" is required but got null");
            

        return new ItemsByMetadataRequestBuilder(from, ancestorFolderId);
    }
    private okhttp3.Call searchCall(String query, String scope, List<String> fileExtensions, List<String> createdAtRange, List<String> updatedAtRange, List<Integer> sizeRange, List<String> ownerUserIds, List<String> recentUpdaterUserIds, List<String> ancestorFolderIds, List<String> contentTypes, String type, String trashContent, List<MetadataFilter> mdfilters, String sort, String direction, Long limit, Boolean includeRecentSharedLinks, List<String> fields, Long offset, List<String> deletedUserIds, List<String> deletedAtRange, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/search";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (query != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("query", query));
        }

        if (scope != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("scope", scope));
        }

        if (fileExtensions != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("csv", "file_extensions", fileExtensions));
        }

        if (createdAtRange != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("csv", "created_at_range", createdAtRange));
        }

        if (updatedAtRange != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("csv", "updated_at_range", updatedAtRange));
        }

        if (sizeRange != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("csv", "size_range", sizeRange));
        }

        if (ownerUserIds != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("csv", "owner_user_ids", ownerUserIds));
        }

        if (recentUpdaterUserIds != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("csv", "recent_updater_user_ids", recentUpdaterUserIds));
        }

        if (ancestorFolderIds != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("csv", "ancestor_folder_ids", ancestorFolderIds));
        }

        if (contentTypes != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("csv", "content_types", contentTypes));
        }

        if (type != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("type", type));
        }

        if (trashContent != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("trash_content", trashContent));
        }

        if (mdfilters != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "mdfilters", mdfilters));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (direction != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("direction", direction));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (includeRecentSharedLinks != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("include_recent_shared_links", includeRecentSharedLinks));
        }

        if (fields != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("csv", "fields", fields));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (deletedUserIds != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "deleted_user_ids", deletedUserIds));
        }

        if (deletedAtRange != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "deleted_at_range", deletedAtRange));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "OAuth2Security" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call searchValidateBeforeCall(String query, String scope, List<String> fileExtensions, List<String> createdAtRange, List<String> updatedAtRange, List<Integer> sizeRange, List<String> ownerUserIds, List<String> recentUpdaterUserIds, List<String> ancestorFolderIds, List<String> contentTypes, String type, String trashContent, List<MetadataFilter> mdfilters, String sort, String direction, Long limit, Boolean includeRecentSharedLinks, List<String> fields, Long offset, List<String> deletedUserIds, List<String> deletedAtRange, final ApiCallback _callback) throws ApiException {
        return searchCall(query, scope, fileExtensions, createdAtRange, updatedAtRange, sizeRange, ownerUserIds, recentUpdaterUserIds, ancestorFolderIds, contentTypes, type, trashContent, mdfilters, sort, direction, limit, includeRecentSharedLinks, fields, offset, deletedUserIds, deletedAtRange, _callback);

    }


    private ApiResponse<Object> searchWithHttpInfo(String query, String scope, List<String> fileExtensions, List<String> createdAtRange, List<String> updatedAtRange, List<Integer> sizeRange, List<String> ownerUserIds, List<String> recentUpdaterUserIds, List<String> ancestorFolderIds, List<String> contentTypes, String type, String trashContent, List<MetadataFilter> mdfilters, String sort, String direction, Long limit, Boolean includeRecentSharedLinks, List<String> fields, Long offset, List<String> deletedUserIds, List<String> deletedAtRange) throws ApiException {
        okhttp3.Call localVarCall = searchValidateBeforeCall(query, scope, fileExtensions, createdAtRange, updatedAtRange, sizeRange, ownerUserIds, recentUpdaterUserIds, ancestorFolderIds, contentTypes, type, trashContent, mdfilters, sort, direction, limit, includeRecentSharedLinks, fields, offset, deletedUserIds, deletedAtRange, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call searchAsync(String query, String scope, List<String> fileExtensions, List<String> createdAtRange, List<String> updatedAtRange, List<Integer> sizeRange, List<String> ownerUserIds, List<String> recentUpdaterUserIds, List<String> ancestorFolderIds, List<String> contentTypes, String type, String trashContent, List<MetadataFilter> mdfilters, String sort, String direction, Long limit, Boolean includeRecentSharedLinks, List<String> fields, Long offset, List<String> deletedUserIds, List<String> deletedAtRange, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = searchValidateBeforeCall(query, scope, fileExtensions, createdAtRange, updatedAtRange, sizeRange, ownerUserIds, recentUpdaterUserIds, ancestorFolderIds, contentTypes, type, trashContent, mdfilters, sort, direction, limit, includeRecentSharedLinks, fields, offset, deletedUserIds, deletedAtRange, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class SearchRequestBuilder {
        private String query;
        private String scope;
        private List<String> fileExtensions;
        private List<String> createdAtRange;
        private List<String> updatedAtRange;
        private List<Integer> sizeRange;
        private List<String> ownerUserIds;
        private List<String> recentUpdaterUserIds;
        private List<String> ancestorFolderIds;
        private List<String> contentTypes;
        private String type;
        private String trashContent;
        private List<MetadataFilter> mdfilters;
        private String sort;
        private String direction;
        private Long limit;
        private Boolean includeRecentSharedLinks;
        private List<String> fields;
        private Long offset;
        private List<String> deletedUserIds;
        private List<String> deletedAtRange;

        private SearchRequestBuilder() {
        }

        /**
         * Set query
         * @param query The string to search for. This query is matched against item names, descriptions, text content of files, and various other fields of the different item types.  This parameter supports a variety of operators to further refine the results returns.  * &#x60;\&quot;\&quot;&#x60; - by wrapping a query in double quotes only exact matches are   returned by the API. Exact searches do not return search matches   based on specific character sequences. Instead, they return   matches based on phrases, that is, word sequences. For example:   A search for &#x60;\&quot;Blue-Box\&quot;&#x60; may return search results including   the sequence &#x60;\&quot;blue.box\&quot;&#x60;, &#x60;\&quot;Blue Box\&quot;&#x60;, and &#x60;\&quot;Blue-Box\&quot;&#x60;;   any item containing the words &#x60;Blue&#x60; and &#x60;Box&#x60; consecutively, in   the order specified. * &#x60;AND&#x60; - returns items that contain both the search terms. For   example, a search for &#x60;marketing AND BoxWorks&#x60; returns items   that have both &#x60;marketing&#x60; and &#x60;BoxWorks&#x60; within its text in any order.   It does not return a result that only has &#x60;BoxWorks&#x60; in its text. * &#x60;OR&#x60; - returns items that contain either of the search terms. For   example, a search for &#x60;marketing OR BoxWorks&#x60; returns a result that   has either &#x60;marketing&#x60; or &#x60;BoxWorks&#x60; within its text. Using this   operator is not necessary as we implicitly interpret multi-word   queries as &#x60;OR&#x60; unless another supported boolean term is used. * &#x60;NOT&#x60; - returns items that do not contain the search term provided.   For example, a search for &#x60;marketing AND NOT BoxWorks&#x60; returns a result   that has only &#x60;marketing&#x60; within its text. Results containing   &#x60;BoxWorks&#x60; are omitted.  We do not support lower case (that is, &#x60;and&#x60;, &#x60;or&#x60;, and &#x60;not&#x60;) or mixed case (that is, &#x60;And&#x60;, &#x60;Or&#x60;, and &#x60;Not&#x60;) operators.  This field is required unless the &#x60;mdfilters&#x60; parameter is defined. (optional)
         * @return SearchRequestBuilder
         */
        public SearchRequestBuilder query(String query) {
            this.query = query;
            return this;
        }
        
        /**
         * Set scope
         * @param scope Limits the search results to either the files that the user has access to, or to files available to the entire enterprise.  The scope defaults to &#x60;user_content&#x60;, which limits the search results to content that is available to the currently authenticated user.  The &#x60;enterprise_content&#x60; can be requested by an admin through our support channels. Once this scope has been enabled for a user, it will allow that use to query for content across the entire enterprise and not only the content that they have access to. (optional, default to user_content)
         * @return SearchRequestBuilder
         */
        public SearchRequestBuilder scope(String scope) {
            this.scope = scope;
            return this;
        }
        
        /**
         * Set fileExtensions
         * @param fileExtensions Limits the search results to any files that match any of the provided file extensions. This list is a comma-separated list of file extensions without the dots. (optional)
         * @return SearchRequestBuilder
         */
        public SearchRequestBuilder fileExtensions(List<String> fileExtensions) {
            this.fileExtensions = fileExtensions;
            return this;
        }
        
        /**
         * Set createdAtRange
         * @param createdAtRange Limits the search results to any items created within a given date range.  Date ranges are defined as comma separated RFC3339 timestamps.  If the the start date is omitted (&#x60;,2014-05-17T13:35:01-07:00&#x60;) anything created before the end date will be returned.  If the end date is omitted (&#x60;2014-05-15T13:35:01-07:00,&#x60;) the current date will be used as the end date instead. (optional)
         * @return SearchRequestBuilder
         */
        public SearchRequestBuilder createdAtRange(List<String> createdAtRange) {
            this.createdAtRange = createdAtRange;
            return this;
        }
        
        /**
         * Set updatedAtRange
         * @param updatedAtRange Limits the search results to any items updated within a given date range.  Date ranges are defined as comma separated RFC3339 timestamps.  If the start date is omitted (&#x60;,2014-05-17T13:35:01-07:00&#x60;) anything updated before the end date will be returned.  If the end date is omitted (&#x60;2014-05-15T13:35:01-07:00,&#x60;) the current date will be used as the end date instead. (optional)
         * @return SearchRequestBuilder
         */
        public SearchRequestBuilder updatedAtRange(List<String> updatedAtRange) {
            this.updatedAtRange = updatedAtRange;
            return this;
        }
        
        /**
         * Set sizeRange
         * @param sizeRange Limits the search results to any items with a size within a given file size range. This applied to files and folders.  Size ranges are defined as comma separated list of a lower and upper byte size limit (inclusive).  The upper and lower bound can be omitted to create open ranges. (optional)
         * @return SearchRequestBuilder
         */
        public SearchRequestBuilder sizeRange(List<Integer> sizeRange) {
            this.sizeRange = sizeRange;
            return this;
        }
        
        /**
         * Set ownerUserIds
         * @param ownerUserIds Limits the search results to any items that are owned by the given list of owners, defined as a list of comma separated user IDs.  The items still need to be owned or shared with the currently authenticated user for them to show up in the search results. If the user does not have access to any files owned by any of the users an empty result set will be returned.  To search across an entire enterprise, we recommend using the &#x60;enterprise_content&#x60; scope parameter which can be requested with our support team. (optional)
         * @return SearchRequestBuilder
         */
        public SearchRequestBuilder ownerUserIds(List<String> ownerUserIds) {
            this.ownerUserIds = ownerUserIds;
            return this;
        }
        
        /**
         * Set recentUpdaterUserIds
         * @param recentUpdaterUserIds Limits the search results to any items that have been updated by the given list of users, defined as a list of comma separated user IDs.  The items still need to be owned or shared with the currently authenticated user for them to show up in the search results. If the user does not have access to any files owned by any of the users an empty result set will be returned.  This feature only searches back to the last 10 versions of an item. (optional)
         * @return SearchRequestBuilder
         */
        public SearchRequestBuilder recentUpdaterUserIds(List<String> recentUpdaterUserIds) {
            this.recentUpdaterUserIds = recentUpdaterUserIds;
            return this;
        }
        
        /**
         * Set ancestorFolderIds
         * @param ancestorFolderIds Limits the search results to items within the given list of folders, defined as a comma separated lists of folder IDs.  Search results will also include items within any subfolders of those ancestor folders.  The folders still need to be owned or shared with the currently authenticated user. If the folder is not accessible by this user, or it does not exist, a &#x60;HTTP 404&#x60; error code will be returned instead.  To search across an entire enterprise, we recommend using the &#x60;enterprise_content&#x60; scope parameter which can be requested with our support team. (optional)
         * @return SearchRequestBuilder
         */
        public SearchRequestBuilder ancestorFolderIds(List<String> ancestorFolderIds) {
            this.ancestorFolderIds = ancestorFolderIds;
            return this;
        }
        
        /**
         * Set contentTypes
         * @param contentTypes Limits the search results to any items that match the search query for a specific part of the file, for example the file description.  Content types are defined as a comma separated lists of Box recognized content types. The allowed content types are as follows.  * &#x60;name&#x60; - The name of the item, as defined by its &#x60;name&#x60; field. * &#x60;description&#x60; - The description of the item, as defined by its   &#x60;description&#x60; field. * &#x60;file_content&#x60; - The actual content of the file. * &#x60;comments&#x60; - The content of any of the comments on a file or    folder. * &#x60;tags&#x60; - Any tags that are applied to an item, as defined by its    &#x60;tags&#x60; field. (optional)
         * @return SearchRequestBuilder
         */
        public SearchRequestBuilder contentTypes(List<String> contentTypes) {
            this.contentTypes = contentTypes;
            return this;
        }
        
        /**
         * Set type
         * @param type Limits the search results to any items of this type. This parameter only takes one value. By default the API returns items that match any of these types.  * &#x60;file&#x60; - Limits the search results to files * &#x60;folder&#x60; - Limits the search results to folders * &#x60;web_link&#x60; - Limits the search results to web links, also known    as bookmarks (optional)
         * @return SearchRequestBuilder
         */
        public SearchRequestBuilder type(String type) {
            this.type = type;
            return this;
        }
        
        /**
         * Set trashContent
         * @param trashContent Determines if the search should look in the trash for items.  By default, this API only returns search results for items not currently in the trash (&#x60;non_trashed_only&#x60;).  * &#x60;trashed_only&#x60; - Only searches for items currently in the trash * &#x60;non_trashed_only&#x60; - Only searches for items currently not in   the trash * &#x60;all_items&#x60; - Searches for both trashed and non-trashed items. (optional, default to non_trashed_only)
         * @return SearchRequestBuilder
         */
        public SearchRequestBuilder trashContent(String trashContent) {
            this.trashContent = trashContent;
            return this;
        }
        
        /**
         * Set mdfilters
         * @param mdfilters Limits the search results to any items for which the metadata matches the provided filter.  This parameter contains a list of 1 metadata template to filter the search results by. This list can currently only contain one entry, though this might be expanded in the future.  This parameter is required unless the &#x60;query&#x60; parameter is provided. (optional)
         * @return SearchRequestBuilder
         */
        public SearchRequestBuilder mdfilters(List<MetadataFilter> mdfilters) {
            this.mdfilters = mdfilters;
            return this;
        }
        
        /**
         * Set sort
         * @param sort Defines the order in which search results are returned. This API defaults to returning items by relevance unless this parameter is explicitly specified.  * &#x60;relevance&#x60; (default) returns the results sorted by relevance to the query search term. The relevance is based on the occurrence of the search term in the items name, description, content, and additional properties. * &#x60;modified_at&#x60; returns the results ordered in descending order by date at which the item was last modified. (optional, default to relevance)
         * @return SearchRequestBuilder
         */
        public SearchRequestBuilder sort(String sort) {
            this.sort = sort;
            return this;
        }
        
        /**
         * Set direction
         * @param direction Defines the direction in which search results are ordered. This API defaults to returning items in descending (&#x60;DESC&#x60;) order unless this parameter is explicitly specified.  When results are sorted by &#x60;relevance&#x60; the ordering is locked to returning items in descending order of relevance, and this parameter is ignored. (optional, default to DESC)
         * @return SearchRequestBuilder
         */
        public SearchRequestBuilder direction(String direction) {
            this.direction = direction;
            return this;
        }
        
        /**
         * Set limit
         * @param limit Defines the maximum number of items to return as part of a page of results. (optional, default to 30)
         * @return SearchRequestBuilder
         */
        public SearchRequestBuilder limit(Long limit) {
            this.limit = limit;
            return this;
        }
        
        /**
         * Set includeRecentSharedLinks
         * @param includeRecentSharedLinks Defines whether the search results should include any items that the user recently accessed through a shared link.  When this parameter has been set to true, the format of the response of this API changes to return a list of [Search Results with Shared Links](r://search_results_with_shared_links) (optional, default to false)
         * @return SearchRequestBuilder
         */
        public SearchRequestBuilder includeRecentSharedLinks(Boolean includeRecentSharedLinks) {
            this.includeRecentSharedLinks = includeRecentSharedLinks;
            return this;
        }
        
        /**
         * Set fields
         * @param fields A comma-separated list of attributes to include in the response. This can be used to request fields that are not normally returned in a standard response.  Be aware that specifying this parameter will have the effect that none of the standard fields are returned in the response unless explicitly specified, instead only fields for the mini representation are returned, additional to the fields requested. (optional)
         * @return SearchRequestBuilder
         */
        public SearchRequestBuilder fields(List<String> fields) {
            this.fields = fields;
            return this;
        }
        
        /**
         * Set offset
         * @param offset The offset of the item at which to begin the response.  Queries with offset parameter value exceeding 10000 will be rejected with a 400 response. (optional, default to 0)
         * @return SearchRequestBuilder
         */
        public SearchRequestBuilder offset(Long offset) {
            this.offset = offset;
            return this;
        }
        
        /**
         * Set deletedUserIds
         * @param deletedUserIds Limits the search results to items that were deleted by the given list of users, defined as a list of comma separated user IDs.  The &#x60;trash_content&#x60; parameter needs to be set to &#x60;trashed_only&#x60;.  If searching in trash is not performed, an empty result set is returned. The items need to be owned or shared with the currently authenticated user for them to show up in the search results.  If the user does not have access to any files owned by any of the users, an empty result set is returned.  Data available from 2023-02-01 onwards. (optional)
         * @return SearchRequestBuilder
         */
        public SearchRequestBuilder deletedUserIds(List<String> deletedUserIds) {
            this.deletedUserIds = deletedUserIds;
            return this;
        }
        
        /**
         * Set deletedAtRange
         * @param deletedAtRange Limits the search results to any items deleted within a given date range.  Date ranges are defined as comma separated RFC3339 timestamps.  If the the start date is omitted (&#x60;2014-05-17T13:35:01-07:00&#x60;), anything deleted before the end date will be returned.  If the end date is omitted (&#x60;2014-05-15T13:35:01-07:00&#x60;), the current date will be used as the end date instead.  The &#x60;trash_content&#x60; parameter needs to be set to &#x60;trashed_only&#x60;.  If searching in trash is not performed, then an empty result is returned.  Data available from 2023-02-01 onwards. (optional)
         * @return SearchRequestBuilder
         */
        public SearchRequestBuilder deletedAtRange(List<String> deletedAtRange) {
            this.deletedAtRange = deletedAtRange;
            return this;
        }
        
        /**
         * Build call for search
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returns a collection of search results. If there are no matching search results, the &#x60;entries&#x60; array will be empty. </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> An unexpected client error. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return searchCall(query, scope, fileExtensions, createdAtRange, updatedAtRange, sizeRange, ownerUserIds, recentUpdaterUserIds, ancestorFolderIds, contentTypes, type, trashContent, mdfilters, sort, direction, limit, includeRecentSharedLinks, fields, offset, deletedUserIds, deletedAtRange, _callback);
        }


        /**
         * Execute search request
         * @return Object
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returns a collection of search results. If there are no matching search results, the &#x60;entries&#x60; array will be empty. </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> An unexpected client error. </td><td>  -  </td></tr>
         </table>
         */
        public Object execute() throws ApiException {
            ApiResponse<Object> localVarResp = searchWithHttpInfo(query, scope, fileExtensions, createdAtRange, updatedAtRange, sizeRange, ownerUserIds, recentUpdaterUserIds, ancestorFolderIds, contentTypes, type, trashContent, mdfilters, sort, direction, limit, includeRecentSharedLinks, fields, offset, deletedUserIds, deletedAtRange);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute search request with HTTP info returned
         * @return ApiResponse&lt;Object&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returns a collection of search results. If there are no matching search results, the &#x60;entries&#x60; array will be empty. </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> An unexpected client error. </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Object> executeWithHttpInfo() throws ApiException {
            return searchWithHttpInfo(query, scope, fileExtensions, createdAtRange, updatedAtRange, sizeRange, ownerUserIds, recentUpdaterUserIds, ancestorFolderIds, contentTypes, type, trashContent, mdfilters, sort, direction, limit, includeRecentSharedLinks, fields, offset, deletedUserIds, deletedAtRange);
        }

        /**
         * Execute search request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Returns a collection of search results. If there are no matching search results, the &#x60;entries&#x60; array will be empty. </td><td>  -  </td></tr>
            <tr><td> 0 </td><td> An unexpected client error. </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Object> _callback) throws ApiException {
            return searchAsync(query, scope, fileExtensions, createdAtRange, updatedAtRange, sizeRange, ownerUserIds, recentUpdaterUserIds, ancestorFolderIds, contentTypes, type, trashContent, mdfilters, sort, direction, limit, includeRecentSharedLinks, fields, offset, deletedUserIds, deletedAtRange, _callback);
        }
    }

    /**
     * Search for content
     * Searches for files, folders, web links, and shared files across the users content or across the entire enterprise.
     * @return SearchRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a collection of search results. If there are no matching search results, the &#x60;entries&#x60; array will be empty. </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected client error. </td><td>  -  </td></tr>
     </table>
     */
    public SearchRequestBuilder search() throws IllegalArgumentException {
        return new SearchRequestBuilder();
    }
}

/*
 * Box Platform API
 * [Box Platform](https://box.dev) provides functionality to provide access to content stored within [Box](https://box.com). It provides endpoints for basic manipulation of files and folders, management of users within an enterprise, as well as more complex topics such as legal holds and retention policies.
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: devrel@box.com
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.api;

import com.konfigthis.client.ApiException;
import com.konfigthis.client.ApiClient;
import com.konfigthis.client.ApiException;
import com.konfigthis.client.Configuration;
import com.konfigthis.client.model.ClientError;
import com.konfigthis.client.model.Events;
import java.time.OffsetDateTime;
import com.konfigthis.client.model.RealtimeServers;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.BeforeAll;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * API tests for EventsApi
 */
@Disabled
public class EventsApiTest {

    private static EventsApi api;

    
    @BeforeAll
    public static void beforeClass() {
        ApiClient apiClient = Configuration.getDefaultApiClient();
        api = new EventsApi(apiClient);
    }

    /**
     * List user and enterprise events
     *
     * Returns up to a year of past events for a given user or for the entire enterprise.  By default this returns events for the authenticated user. To retrieve events for the entire enterprise, set the &#x60;stream_type&#x60; to &#x60;admin_logs_streaming&#x60; for live monitoring of new events, or &#x60;admin_logs&#x60; for querying across historical events. The user making the API call will need to have admin privileges, and the application will need to have the scope &#x60;manage enterprise properties&#x60; checked.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void eventsTest() throws ApiException {
        String streamType = null;
        String streamPosition = null;
        Long limit = null;
        List<String> eventType = null;
        OffsetDateTime createdAfter = null;
        OffsetDateTime createdBefore = null;
        Events response = api.events()
                .streamType(streamType)
                .streamPosition(streamPosition)
                .limit(limit)
                .eventType(eventType)
                .createdAfter(createdAfter)
                .createdBefore(createdBefore)
                .execute();
        // TODO: test validations
    }

    /**
     * Get events long poll endpoint
     *
     * Returns a list of real-time servers that can be used for long-polling updates to the [event stream](https://raw.githubusercontent.com).  Long polling is the concept where a HTTP request is kept open until the server sends a response, then repeating the process over and over to receive updated responses.  Long polling the event stream can only be used for user events, not for enterprise events.  To use long polling, first use this endpoint to retrieve a list of long poll URLs. Next, make a long poll request to any of the provided URLs.  When an event occurs in monitored account a response with the value &#x60;new_change&#x60; will be sent. The response contains no other details as it only serves as a prompt to take further action such as sending a request to the [events endpoint](https://raw.githubusercontent.com) with the last known &#x60;stream_position&#x60;.  After the server sends this response it closes the connection. You must now repeat the long poll process to begin listening for events again.  If no events occur for a while and the connection times out you will receive a response with the value &#x60;reconnect&#x60;. When you receive this response youâ€™ll make another call to this endpoint to restart the process.  If you receive no events in &#x60;retry_timeout&#x60; seconds then you will need to make another request to the real-time server (one of the URLs in the response for this endpoint). This might be necessary due to network errors.  Finally, if you receive a &#x60;max_retries&#x60; error when making a request to the real-time server, you should start over by making a call to this endpoint first.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void events_0Test() throws ApiException {
        RealtimeServers response = api.events_0()
                .execute();
        // TODO: test validations
    }

}
